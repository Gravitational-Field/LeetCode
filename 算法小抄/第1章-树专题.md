# 1. 题目

### 1.1 二叉树

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

将

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

翻转为：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

可以看到左右子树进行了镜像翻转。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //终局条件
        if(root == null) return null;

        //前序遍历位置
        //root节点需要交换它的左右子节点
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
		
        //左右子节点分别翻转它们的子节点
        invertTree(root.left);
        invertTree(root.right);
		
        //所需条件
        return root;
    }
}
```

> 思路：
>
> 二叉树问题，全都是前序遍历、中序遍历、后序遍历等问题。这道题只需交换每个根节点的左右子树即可。则**子单元为交换**，可以当做一开始我们有这个函数，完成任务为进行左右子树的交换，采用何种遍历操作，**前序可以，后序也可以。中序不可以。 是因为中序遍历更换了节点，根据左根右的遍历顺序，相当于左侧节点交换到右侧后，又对其进行交换，相当于交换了两次，而右侧节点没换，所以右子树没有被翻转。**

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

![image-20201227101842462](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201227101842.png)

题目说了，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点 `next` 指针会指向 `null`，其他节点的右侧一定有相邻的节点。

- 错误解法

```java
Node connect(Node root) {
    if (root == null || root.left == null) {
        return root;
    }

    root.left.next = root.right;

    connect(root.left);
    connect(root.right);

    return root;
}
```

存在问题：

![image-20201227102034780](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201227102034.png)

节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。

**二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情**，但是如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的（打脸，事实上可以利用先前已经构建好的next指针，来获得比如说5->6,可通过2->next->6）。

我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」：

```java
// 主函数
Node connect(Node root) {
    if (root == null) return null;
    connectTwoNode(root.left, root.right);
    return root;
}

// 辅助函数
void connectTwoNode(Node node1, Node node2) {
    if (node1 == null || node2 == null) {
        return; //程序结束
    }
    /**** 前序遍历位置 ****/
    // 将传入的两个节点连接
    node1.next = node2;

    // 连接相同父节点的两个子节点
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // 连接跨越父节点的两个子节点
    connectTwoNode(node1.right, node2.left);
}
```

这样，`connectTwoNode` 函数不断递归，可以无死角覆盖整棵二叉树，将所有相邻节点都连接起来，也就避免了我们之前出现的问题，但是时间超出了限制。

- 最终解法

> 目的是获得非同父节点的相邻节点，可以通过当前的父节点的next解决。即可满足时间复杂度的要求。

```java
class Solution {
    public Node connect(Node root) {
        if(root == null || root.left == null) 
            return root;
        root.left.next = root.right;
        if(root.next != null){
            root.right.next = root.next.left;
        }
        connect(root.left);
        connect(root.right);
        return root;
    }
}
```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

给定一个二叉树，原地将它展开为一个单链表。

例如，给定二叉树

![image-20201229210030707](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201229210037.png)

将其展开为：

![image-20201229210047691](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201229210047.png)

- 思考

**给flatten函数输入一个节点`root`,则会将以`root`为根的二叉树拉平为一条链表。**

如何能将这棵树拉平？

1. 将`root`的左子树拉平，将`root`的右子树拉平.
2. ~~将`root`的右子树接到左子树最后位置~~
3. ~~将`root`的整个左子树接到`root`的右侧.~~

2. 将左子树接到root的右侧位置
3. 将原先右子树接到当前右子树（原左子树）的最后位置

> 上边的在编码时有问题，因为右子树先接到左子树时，不方便找到其最后的节点位置；而将左子树接到root的右侧位置后，可以比较方便的找到最后的节点位置。

**左右根**，可知是后序遍历方式。

![image-20201229214903576](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201229214903.png)

上面三步看起来最难的应该是第一步对吧，如何把 `root` 的左右子树拉平？其实很简单，按照 `flatten` 函数的定义，对 `root` 的左右子树递归调用 `flatten` 函数即可：

```java
// 定义：将以 root 为根的树拉平为链表
void flatten(TreeNode root) {
    // base case
    if (root == null) return;

    flatten(root.left);
    flatten(root.right);

    /**** 后序遍历位置 ****/
    // 1、左右子树已经被拉平成一条链表
    TreeNode left = root.left;
    TreeNode right = root.right;

    // 2、将左子树作为右子树
    root.left = null;
    root.right = left;

    // 3、将原先的右子树接到当前右子树的末端
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
}
```

这就是递归的魅力，你说 `flatten` 函数是怎么把左右子树拉平的？说不清楚，但是只要知道 `flatten` 的定义如此，相信这个定义，让 `root` 做它该做的事情，然后 `flatten` 函数就会按照定义工作。**另外注意递归框架是后序遍历，因为我们要先拉平左右子树才能进行后续操作。**

#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

- [构造最大二叉树过程解析](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/shou-ba-shou-shua-er-cha-shu-xun-lian-di-gui-si-wei/er-cha-shu-xi-lie-2)

![image-20201231092542452](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201231092542.png)

函数签名如下：

```java
 TreeNode constructMaximumBinaryTree(int[] nums);
```

思考过程： 构造二叉树

1.  构造根节点
2. 构造左右子树
3. 返回根

步骤：

- 构造根节点
  - 找到数组中的最大值
  - 构造根节点
- 构造相应的左右子树
- 返回根

> 单个节点要做的任务为上边所描述，采用根左右的前序遍历来进行。

```java
class Solution {
    /* 主函数 */
    TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums, 0, nums.length - 1);
    }

    /* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */
    TreeNode build(int[] nums, int lo, int hi) {
        // base case
        if (lo > hi) {
            return null;
        }

        // 找到数组中的最大值和对应的索引
        int index = -1, maxVal = Integer.MIN_VALUE;
        for (int i = lo; i <= hi; i++) {
            if (maxVal < nums[i]) {
                index = i;
                maxVal = nums[i];
            }
        }

        TreeNode root = new TreeNode(maxVal);
        // 递归调用构造左右子树
        root.left = build(nums, lo, index - 1);
        root.right = build(nums, index + 1, hi);

        return root;
    }
}
```

#### [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

- [寻找重复的子树解析](https://mp.weixin.qq.com/s/LJbpo49qppIeRs-FbgjsSQ)

![image-20201231093522645](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201231093522.png)

因此，你需要以列表的形式返回上述重复子树的根结点。

- 函数签名

```java
List<TreeNode> findDuplicateSubtrees(TreeNode root);
```

解释下题目，输入是一棵二叉树的根节点`root`，返回的是一个列表，里面装着若干个二叉树节点，这些节点对应的子树在原二叉树中是存在重复的。



**老套路，先思考，对于某一个节点，它应该做什么**。

比如说，你站在图中这个节点 2 上：



![image-20201231094005929](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201231094005.png)

如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？

**你需要知道以下两点**：

**1、以我为根的这棵二叉树（子树）长啥样**？

**2、以其他节点为根的子树都长啥样**？

这就叫知己知彼嘛，我得知道自己长啥样，还得知道别人长啥样，然后才能知道有没有人跟我重复，对不对？

好，那我们一个一个来解决，先来思考，**我如何才能知道以自己为根的二叉树长啥样**？

其实看到这个问题，就可以判断本题要使用「后序遍历」框架来解决：

```java
void traverse(TreeNode root) {
    traverse(root.left);
    traverse(root.right);
    /* 解法代码的位置 */
}
```

为什么？很简单呀，我要知道以自己为根的子树长啥样，是不是得先知道我的左右子树长啥样，再加上自己，就构成了整棵子树的样子？

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？我们前文 [序列化和反序列化二叉树](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect) 其实写过了，二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。

所以，我们可以通过拼接字符串的方式把二叉树序列化，看下代码：

```java
String traverse(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return "#";
    }
    // 将左右子树序列化成字符串
    String left = traverse(root.left);
    String right = traverse(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String subTree = left + "," + right + "," + root.val;
    return subTree;
}
```

我们用非数字的特殊符`#`表示空指针，并且用字符`,`分隔每个二叉树节点值，这属于序列化二叉树的套路了，不多说。

注意我们`subTree`是按照左子树、右子树、根节点这样的顺序拼接字符串，也就是后序遍历顺序。你完全可以按照前序或者中序的顺序拼接字符串，因为这里只是为了描述一棵二叉树的样子，什么顺序不重要。

```java
// 记录所有子树以及出现的次数
HashMap<String, Integer> memo = new HashMap<>();
// 记录重复的子树根节点
LinkedList<TreeNode> res = new LinkedList<>();

/* 主函数 */
List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    traverse(root);
    return res;
}

/* 辅助函数 */
String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }

    String left = traverse(root.left);
    String right = traverse(root.right);

    String subTree = left + "," + right+ "," + root.val;

    int freq = memo.getOrDefault(subTree, 0);
    // 多次重复也只会被加入结果集一次
    if (freq == 1) {
        res.add(root);
    }
    // 给子树对应的出现次数加一
    memo.put(subTree, freq + 1);
    return subTree;
}
```

**特别地：**

1. map的方法： **getOrDefault(key,default)**

```
通过key，获得value；若不存在相应的key，则返回default的值
```

2. 计算数组中的最大值（在不需要获得其索引时使用）

```java
System.out.println(Arrays.stream(nums).max().getAsInt());  //使用这个函数
```

3. 快速输出数组

```java
System.out.println(Arrays.toString(nums));
```



#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

- [二叉树序列化与反序列化思路解析](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect)

![image-20201231150555435](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201231150555.png)

并非必须采取这种方式，也可以采用其他的方法解决这个问题

- 函数签名

```java
public class Codec {

    // 把一棵二叉树序列化成字符串
    public String serialize(TreeNode root);
    
    // 把字符串反序列化成二叉树
    public TreeNode deserialize(String data);
}
```

​		使用`serialize`将二叉树序列化为字符串，用`deserialize`将字符串再反序列化为二叉树。关键问题是将二叉树组织为哪种格式。

比如输入如下这样一棵二叉树：

<img src="https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201231151515.png" alt="image-20201231151515348" style="zoom: 80%;" />

使用 # 号作为null，并使用逗号`,`进行间隔两个节点。故考虑二叉树的遍历方式；

- 迭代方式： 层级遍历 （2,1,3,#,6,#,#）
- 递归遍历： 前序遍历（2,1,#,6,3,#,#）、中序遍历（#,1,6,2,#,#,3）、后续遍历（#,6,1,#,#,3,2）。



- 前序遍历

```java
//编码
String NULL = "#";
String SEG = ",";

// Encodes a tree to a single string.
public String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    encoder(root, sb);
    return sb.toString();
}

public void encoder(TreeNode root, StringBuilder sb) {
    //编码为字符串，#号为null节点，逗号作为分隔符

    if (root == null) {
        sb.append(NULL).append(SEG);
        return;
    }

    //使用前序遍历   根左右
    sb.append(root.val).append(SEG);
    //左右
    encoder(root.left, sb);
    encoder(root.right, sb);

}
```

```java
//解码
// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    String[] dataArr = data.split(SEG);
    LinkedList<String> list = new LinkedList<>();

    for(String str: dataArr) {
        list.addLast(str);
    }
    return decoder(list);
}

public TreeNode decoder(LinkedList<String> list) {
    //主要任务是构建节点;采用  前序遍历的方式   根左右
    if(list == null || list.isEmpty()){
        return null;
    }

    //列表不为空
    String first = list.removeFirst();
    if(NULL.equals(first)){
        return null;
    }

    int val = Integer.parseInt(first);
    //根   左右
    TreeNode root = new TreeNode(val);
    root.left = decoder(list);
    root.right = decoder(list);
    return root;
}
```

- 后续遍历

```java
// Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        encoder(root, sb);
        return sb.toString();
    }

    public void encoder(TreeNode root, StringBuilder sb) {
        //编码为字符串，#号为null节点，逗号作为分隔符
        
        if (root == null) {
            sb.append(NULL).append(SEG);
            return;
        }
        
        //使用后序遍历   左右根
        //左右
        encoder(root.left, sb);
        encoder(root.right, sb);
        //根
        sb.append(root.val).append(SEG);

    }
```



```java
 // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] dataArr = data.split(SEG);
        LinkedList<String> list = new LinkedList<>();

        for(String str: dataArr) {
            list.addLast(str);
        }
        return decoder(list);
    }

    public TreeNode decoder(LinkedList<String> list) {
        //主要任务是构建节点;采用  前序遍历的方式   根左右
        if(list == null || list.isEmpty()){
            return null;
        }

        //列表不为空
        String last = list.removeLast();
        if(NULL.equals(last)){
            return null;
        }

        int val = Integer.parseInt(last);
        //根   右  左
        TreeNode root = new TreeNode(val);
        //右
        root.right = decoder(list);
        //左
        root.left = decoder(list);
        return root;
    }
```

- 中序遍历

  无法实现二叉树的序列化和反序列化，编码比较方便，但是在反构建二叉树时，无法确定根节点的确切位置在哪里。

- 层级遍历

```java
String NULL = "#";
String SEP = ",";

// Encodes a tree to a single string.
public String serialize(TreeNode root) {
    //编码为字符串，#号为null节点，逗号作为分隔符
    //使用层序遍历
    if(root == null) {
        return null;
    }

    StringBuilder sb = new StringBuilder();
    //并将根节点插入到队列中
    Deque<TreeNode> deque = new LinkedList<>();
    deque.addLast(root); //尾插

    while(!deque.isEmpty()) {
        TreeNode cur = deque.removeFirst();
        //当前未null
        if(cur == null) {
            sb.append(NULL).append(SEP);
            continue;
        }
        sb.append(cur.val).append(SEP);

        //处理左节点
        deque.addLast(cur.left);

        //处理右节点
        deque.addLast(cur.right);
    }
    return sb.toString();
}
```



```java
// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    if(data == null) {
        return null;
    }
    //主要任务是构建节点;采用  层序遍历的方式
    String[] dataArr = data.split(SEP);
    TreeNode root = new TreeNode(Integer.parseInt(dataArr[0]));

    Deque<TreeNode> deque = new LinkedList<>();
    deque.addLast(root);

    for(int i = 1; i < dataArr.length;) {
        //deque中存的均为父节点
        TreeNode parent = deque.removeFirst();

        //父节点的左侧子节点
        String leftStr = dataArr[i++];
        if(!NULL.equals(leftStr)) {
            parent.left = new TreeNode(Integer.parseInt(leftStr));
            deque.addLast(parent.left);
        } else {
            parent.left = null;
        }
        //父节点的右侧子节点
        String rightStr = dataArr[i++];
        if(!NULL.equals(rightStr)) {
            parent.right = new TreeNode(Integer.parseInt(rightStr));
            deque.addLast(parent.right);
        } else{
            parent.right = null;
        }
        //如果为NULL,直接continue就行，因为构建的parent其左右节点默认为空，故不用考虑
    }
    return root;
}
```



### 1.2 二叉搜索树（重要等级：五颗星）

> 

#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

- [二叉搜索树中第K小的元素解析](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488101&idx=1&sn=6041ddda5f20ccde8a7036d3e3a1482c&chksm=9bd7ec6daca0657b2ab20a936437e2c8206384c3b1485fe91747ad796fa3a5b08556b2f4911e&scene=21#wechat_redirect)

> 思路：利用二叉搜索树的中序遍历是有顺序的来进行获取第k个值。但其算法复杂度为O(n)，

```java
int val = 0;
int rank = 0;
public int kthSmallest(TreeNode root, int k) {

    traverse(root,k);
    return val;
}

public void traverse(TreeNode root, int k) {
    //采用中序遍历，二叉搜索树的中序遍历时按照从小到大的顺序
    if(root == null) {
        return;
    }

    //左
    kthSmallest(root.left,k);
    //根：中序遍历位置
    rank++;
    if(k == rank) {
        val = root.val;
        return;
    }

    //右
    kthSmallest(root.right,k);
}
```

#### [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)







#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

#### [1038. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/)

- [把二叉搜索树转换为累加树 解析](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488101&idx=1&sn=6041ddda5f20ccde8a7036d3e3a1482c&chksm=9bd7ec6daca0657b2ab20a936437e2c8206384c3b1485fe91747ad796fa3a5b08556b2f4911e&scene=21#wechat_redirect)

> 思路：利用二叉搜索树中序遍历的性质，其中序遍历（左根右）是按照从小到大的顺序进行排列。则（右根左）则是按照从大到小的顺序进行排列。更新当前节点的值时，可以通过设定的累加器，将比其大的节点的值进行相加。并更新当前节点即可。

```java
public TreeNode convertBST(TreeNode root) {
    //考虑采用二叉搜索树的反顺序，  右根左
    //返回最后的根节点
    //每个节点要做的是求得自己的val与前边val的和，采用中序遍历的反顺序，可以从大到小的对树进行排序
    traverse(root);
    return root;
}

int sum = 0;//用于存储所有的比当前节点大的值
public void traverse(TreeNode root) {
    if(root == null) {
        return;
    }

    //右
    traverse(root.right);
    //根
    //获取当前与先前大于该节点的val之和
    sum += root.val;
    //保存在当前值中
    root.val = sum;

    //左
    traverse(root.left);
}
```



# 2. 总结

递归算法的关键要明确函数的定义，相信这个定义，而不要跳进递归细节。

写二叉树的算法题，都是基于递归框架的，我们先要搞清楚 `root` 节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。

二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么，这个只能通过多刷题进行练习了。

- 使用树的递归遍历时，一般不会使用索引，也不会使用for循环；
- 而使用树的层次遍历时，可以使用索引来控制结束；



# 3. 树基础知识

- 前序遍历模板

- 中序遍历模板

- 后序遍历模板

- 层序遍历模板

  ```java
  void traverse(TreeNode root) {
      if (root == null) return;
      // 初始化队列，将 root 加入队列
      Queue<TreeNode> q = new LinkedList<>();
      q.offer(root);
  
      while (!q.isEmpty()) {
          TreeNode cur = q.poll();
  
          /* 层级遍历代码位置 */
          System.out.println(root.val);
          /*****************/
  
          if (cur.left != null) {
              q.offer(cur.left);
          }
  
          if (cur.right != null) {
              q.offer(cur.right);
          }
      }
  }
  ```

  

  **二叉搜索树：**

  > 二叉搜索树（Binary Search Tree，简写 BST）

  - 二叉搜索树特性

  1. 对于 BST 的每一个节点`node`，左子树节点的值都比`node`的值要小，右子树节点的值都比`node`的值大。
  2. 对于 BST 的每一个节点`node`，它的左侧子树和右侧子树都是 BST。

  二叉搜索树并不算复杂，但我觉得它构建起了数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

  **从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）**。

  ```java
  //BST的中序遍历
  void traverse(TreeNode root) {
      if (root == null) return;
      traverse(root.left);
      // 中序遍历代码位置
      print(root.val);
      traverse(root.right);
  }
  ```

  

  ​	

# 4. 技巧总结

- 巧妙获得数组中的最大值

```java
//将一个数组放进 stream 里面，然后直接调用 stream 里的 min 或 max 函数得到最大值。
int ages[] = {18 ,23 ,21 ,19 ,25 ,29 ,17};
int maxNum = Arrays.stream(ages).max().getAsInt();
System.out.println("最大值为："+ maxNum);
```

- 需要使用queue或者stack时，改用deque

```java
//deque更灵活，扩容策略更友好
Deque<TreeNode> deque = new LinkedList<>();

//替代queue时，可采用：
deque.addLast()
deque.removeFirst()
    
//替代stack时，可采用：
deque.addLast()
deque.removeLast()
```





